package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"context"

	"hmans.dev/beans/internal/bean"
	"hmans.dev/beans/internal/beancore"
	"hmans.dev/beans/internal/graph/model"
)

// Links is the resolver for the links field.
func (r *beanResolver) Links(ctx context.Context, obj *bean.Bean) ([]*bean.Link, error) {
	// Convert []Link to []*Link
	result := make([]*bean.Link, len(obj.Links))
	for i := range obj.Links {
		result[i] = &obj.Links[i]
	}
	return result, nil
}

// BlockedBy is the resolver for the blockedBy field.
func (r *beanResolver) BlockedBy(ctx context.Context, obj *bean.Bean) ([]*bean.Bean, error) {
	incoming := r.Core.FindIncomingLinks(obj.ID)
	var result []*bean.Bean
	for _, link := range incoming {
		if link.LinkType == "blocks" {
			result = append(result, link.FromBean)
		}
	}
	return result, nil
}

// Blocks is the resolver for the blocks field.
func (r *beanResolver) Blocks(ctx context.Context, obj *bean.Bean) ([]*bean.Bean, error) {
	var result []*bean.Bean
	for _, link := range obj.Links {
		if link.Type == "blocks" {
			// Filter out broken links
			if target, err := r.Core.Get(link.Target); err == nil {
				result = append(result, target)
			}
		}
	}
	return result, nil
}

// Parent is the resolver for the parent field.
func (r *beanResolver) Parent(ctx context.Context, obj *bean.Bean) (*bean.Bean, error) {
	for _, link := range obj.Links {
		if link.Type == "parent" {
			// Filter out broken links
			if target, err := r.Core.Get(link.Target); err == nil {
				return target, nil
			}
		}
	}
	return nil, nil
}

// Children is the resolver for the children field.
func (r *beanResolver) Children(ctx context.Context, obj *bean.Bean) ([]*bean.Bean, error) {
	incoming := r.Core.FindIncomingLinks(obj.ID)
	var result []*bean.Bean
	for _, link := range incoming {
		if link.LinkType == "parent" {
			result = append(result, link.FromBean)
		}
	}
	return result, nil
}

// Duplicates is the resolver for the duplicates field.
// Bidirectional: returns both outgoing and incoming 'duplicates' links.
func (r *beanResolver) Duplicates(ctx context.Context, obj *bean.Bean) ([]*bean.Bean, error) {
	seen := make(map[string]bool)
	var result []*bean.Bean

	// Outgoing links
	for _, link := range obj.Links {
		if link.Type == "duplicates" {
			if target, err := r.Core.Get(link.Target); err == nil && !seen[target.ID] {
				seen[target.ID] = true
				result = append(result, target)
			}
		}
	}

	// Incoming links
	for _, link := range r.Core.FindIncomingLinks(obj.ID) {
		if link.LinkType == "duplicates" && !seen[link.FromBean.ID] {
			seen[link.FromBean.ID] = true
			result = append(result, link.FromBean)
		}
	}

	return result, nil
}

// Related is the resolver for the related field.
// Bidirectional: returns both outgoing and incoming 'related' links.
func (r *beanResolver) Related(ctx context.Context, obj *bean.Bean) ([]*bean.Bean, error) {
	seen := make(map[string]bool)
	var result []*bean.Bean

	// Outgoing links
	for _, link := range obj.Links {
		if link.Type == "related" {
			if target, err := r.Core.Get(link.Target); err == nil && !seen[target.ID] {
				seen[target.ID] = true
				result = append(result, target)
			}
		}
	}

	// Incoming links
	for _, link := range r.Core.FindIncomingLinks(obj.ID) {
		if link.LinkType == "related" && !seen[link.FromBean.ID] {
			seen[link.FromBean.ID] = true
			result = append(result, link.FromBean)
		}
	}

	return result, nil
}

// TargetBean is the resolver for the targetBean field.
func (r *linkResolver) TargetBean(ctx context.Context, obj *bean.Link) (*bean.Bean, error) {
	// Filter out broken links by returning nil
	target, err := r.Core.Get(obj.Target)
	if err == beancore.ErrNotFound {
		return nil, nil
	}
	return target, err
}

// Bean is the resolver for the bean field.
func (r *queryResolver) Bean(ctx context.Context, id string) (*bean.Bean, error) {
	b, err := r.Core.Get(id)
	if err == beancore.ErrNotFound {
		return nil, nil
	}
	return b, err
}

// Beans is the resolver for the beans field.
func (r *queryResolver) Beans(ctx context.Context, filter *model.BeanFilter) ([]*bean.Bean, error) {
	beans := r.Core.All()

	if filter == nil {
		return beans, nil
	}

	// Apply filters
	result := beans

	// Status filters
	if len(filter.Status) > 0 {
		result = filterByField(result, filter.Status, func(b *bean.Bean) string { return b.Status })
	}
	if len(filter.ExcludeStatus) > 0 {
		result = excludeByField(result, filter.ExcludeStatus, func(b *bean.Bean) string { return b.Status })
	}

	// Type filters
	if len(filter.Type) > 0 {
		result = filterByField(result, filter.Type, func(b *bean.Bean) string { return b.Type })
	}
	if len(filter.ExcludeType) > 0 {
		result = excludeByField(result, filter.ExcludeType, func(b *bean.Bean) string { return b.Type })
	}

	// Priority filters (empty priority treated as "normal")
	if len(filter.Priority) > 0 {
		result = filterByPriority(result, filter.Priority)
	}
	if len(filter.ExcludePriority) > 0 {
		result = excludeByPriority(result, filter.ExcludePriority)
	}

	// Tag filters
	if len(filter.Tags) > 0 {
		result = filterByTags(result, filter.Tags)
	}
	if len(filter.ExcludeTags) > 0 {
		result = excludeByTags(result, filter.ExcludeTags)
	}

	// Link filters
	if len(filter.HasLinks) > 0 {
		result = filterByOutgoingLinks(result, filter.HasLinks)
	}
	if len(filter.NoLinks) > 0 {
		result = excludeByOutgoingLinks(result, filter.NoLinks)
	}
	if len(filter.LinkedAs) > 0 {
		result = filterByIncomingLinks(result, filter.LinkedAs, r.Core)
	}
	if len(filter.NoLinkedAs) > 0 {
		result = excludeByIncomingLinks(result, filter.NoLinkedAs, r.Core)
	}

	return result, nil
}

// Bean returns BeanResolver implementation.
func (r *Resolver) Bean() BeanResolver { return &beanResolver{r} }

// Link returns LinkResolver implementation.
func (r *Resolver) Link() LinkResolver { return &linkResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type beanResolver struct{ *Resolver }
type linkResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
