package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"context"
	"fmt"

	"github.com/hmans/beans/internal/bean"
	"github.com/hmans/beans/internal/beancore"
	"github.com/hmans/beans/internal/graph/model"
)

// ParentID is the resolver for the parentId field.
func (r *beanResolver) ParentID(ctx context.Context, obj *bean.Bean) (*string, error) {
	if obj.Parent == "" {
		return nil, nil
	}
	return &obj.Parent, nil
}

// BlockingIds is the resolver for the blockingIds field.
func (r *beanResolver) BlockingIds(ctx context.Context, obj *bean.Bean) ([]string, error) {
	return obj.Blocking, nil
}

// BlockedBy is the resolver for the blockedBy field.
func (r *beanResolver) BlockedBy(ctx context.Context, obj *bean.Bean, filter *model.BeanFilter) ([]*bean.Bean, error) {
	incoming := r.Core.FindIncomingLinks(obj.ID)
	var result []*bean.Bean
	for _, link := range incoming {
		if link.LinkType == "blocking" {
			result = append(result, link.FromBean)
		}
	}
	return ApplyFilter(result, filter, r.Core), nil
}

// Blocking is the resolver for the blocking field.
func (r *beanResolver) Blocking(ctx context.Context, obj *bean.Bean, filter *model.BeanFilter) ([]*bean.Bean, error) {
	var result []*bean.Bean
	for _, targetID := range obj.Blocking {
		// Filter out broken links
		if target, err := r.Core.Get(targetID); err == nil {
			result = append(result, target)
		}
	}
	return ApplyFilter(result, filter, r.Core), nil
}

// Parent is the resolver for the parent field.
func (r *beanResolver) Parent(ctx context.Context, obj *bean.Bean) (*bean.Bean, error) {
	if obj.Parent == "" {
		return nil, nil
	}
	// Filter out broken links
	parent, err := r.Core.Get(obj.Parent)
	if err == beancore.ErrNotFound {
		return nil, nil
	}
	return parent, err
}

// Children is the resolver for the children field.
func (r *beanResolver) Children(ctx context.Context, obj *bean.Bean, filter *model.BeanFilter) ([]*bean.Bean, error) {
	incoming := r.Core.FindIncomingLinks(obj.ID)
	var result []*bean.Bean
	for _, link := range incoming {
		if link.LinkType == "parent" {
			result = append(result, link.FromBean)
		}
	}
	return ApplyFilter(result, filter, r.Core), nil
}

// CreateBean is the resolver for the createBean field.
func (r *mutationResolver) CreateBean(ctx context.Context, input model.CreateBeanInput) (*bean.Bean, error) {
	b := &bean.Bean{
		Slug:     bean.Slugify(input.Title),
		Title:    input.Title,
		Type:     "task", // default
		Blocking: []string{},
	}

	// Optional fields with defaults documented in schema
	if input.Type != nil {
		b.Type = *input.Type
	}
	if input.Status != nil {
		b.Status = *input.Status
	}
	if input.Priority != nil {
		b.Priority = *input.Priority
	}
	if input.Body != nil {
		b.Body = *input.Body
	}
	if len(input.Tags) > 0 {
		b.Tags = input.Tags
	}

	// Handle parent (with validation)
	if input.Parent != nil && *input.Parent != "" {
		if err := r.Core.ValidateParent(b, *input.Parent); err != nil {
			return nil, err
		}
		b.Parent = *input.Parent
	}

	// Handle blocking
	if len(input.Blocking) > 0 {
		b.Blocking = input.Blocking
	}

	if err := r.Core.Create(b); err != nil {
		return nil, err
	}

	return b, nil
}

// UpdateBean is the resolver for the updateBean field.
func (r *mutationResolver) UpdateBean(ctx context.Context, id string, input model.UpdateBeanInput) (*bean.Bean, error) {
	b, err := r.Core.Get(id)
	if err != nil {
		return nil, err
	}

	// Update fields if provided
	if input.Title != nil {
		b.Title = *input.Title
	}
	if input.Status != nil {
		b.Status = *input.Status
	}
	if input.Type != nil {
		b.Type = *input.Type
	}
	if input.Priority != nil {
		b.Priority = *input.Priority
	}
	if input.Body != nil {
		b.Body = *input.Body
	}
	if input.Tags != nil {
		b.Tags = input.Tags
	}

	if err := r.Core.Update(b); err != nil {
		return nil, err
	}

	return b, nil
}

// DeleteBean is the resolver for the deleteBean field.
func (r *mutationResolver) DeleteBean(ctx context.Context, id string) (bool, error) {
	// Verify bean exists
	_, err := r.Core.Get(id)
	if err != nil {
		return false, err
	}

	// Remove incoming links first
	if _, err := r.Core.RemoveLinksTo(id); err != nil {
		return false, err
	}

	// Delete the bean
	if err := r.Core.Delete(id); err != nil {
		return false, err
	}

	return true, nil
}

// SetParent is the resolver for the setParent field.
func (r *mutationResolver) SetParent(ctx context.Context, id string, parentID *string) (*bean.Bean, error) {
	b, err := r.Core.Get(id)
	if err != nil {
		return nil, err
	}

	newParent := ""
	if parentID != nil {
		newParent = *parentID
	}

	// Validate parent type hierarchy
	if newParent != "" {
		if err := r.Core.ValidateParent(b, newParent); err != nil {
			return nil, err
		}
		// Check for cycles
		if cycle := r.Core.DetectCycle(b.ID, "parent", newParent); cycle != nil {
			return nil, fmt.Errorf("would create cycle: %v", cycle)
		}
	}

	b.Parent = newParent
	if err := r.Core.Update(b); err != nil {
		return nil, err
	}
	return b, nil
}

// AddBlocking is the resolver for the addBlocking field.
func (r *mutationResolver) AddBlocking(ctx context.Context, id string, targetID string) (*bean.Bean, error) {
	b, err := r.Core.Get(id)
	if err != nil {
		return nil, err
	}

	if targetID == b.ID {
		return nil, fmt.Errorf("bean cannot block itself")
	}

	// Check target exists
	if _, err := r.Core.Get(targetID); err != nil {
		return nil, fmt.Errorf("target bean not found: %s", targetID)
	}

	// Check for cycles
	if cycle := r.Core.DetectCycle(b.ID, "blocking", targetID); cycle != nil {
		return nil, fmt.Errorf("would create cycle: %v", cycle)
	}

	b.AddBlocking(targetID)
	if err := r.Core.Update(b); err != nil {
		return nil, err
	}
	return b, nil
}

// RemoveBlocking is the resolver for the removeBlocking field.
func (r *mutationResolver) RemoveBlocking(ctx context.Context, id string, targetID string) (*bean.Bean, error) {
	b, err := r.Core.Get(id)
	if err != nil {
		return nil, err
	}

	b.RemoveBlocking(targetID)
	if err := r.Core.Update(b); err != nil {
		return nil, err
	}
	return b, nil
}

// Bean is the resolver for the bean field.
func (r *queryResolver) Bean(ctx context.Context, id string) (*bean.Bean, error) {
	b, err := r.Core.Get(id)
	if err == beancore.ErrNotFound {
		return nil, nil
	}
	return b, err
}

// Beans is the resolver for the beans field.
func (r *queryResolver) Beans(ctx context.Context, filter *model.BeanFilter) ([]*bean.Bean, error) {
	var beans []*bean.Bean

	// If search filter is provided, start with search results
	if filter != nil && filter.Search != nil && *filter.Search != "" {
		searchResults, err := r.Core.Search(*filter.Search)
		if err != nil {
			return nil, err
		}
		beans = searchResults
	} else {
		beans = r.Core.All()
	}

	return ApplyFilter(beans, filter, r.Core), nil
}

// Bean returns BeanResolver implementation.
func (r *Resolver) Bean() BeanResolver { return &beanResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type beanResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
