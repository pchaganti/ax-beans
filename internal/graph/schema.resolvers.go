package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"context"

	"github.com/hmans/beans/internal/bean"
	"github.com/hmans/beans/internal/beancore"
	"github.com/hmans/beans/internal/graph/model"
)

// Links is the resolver for the links field.
func (r *beanResolver) Links(ctx context.Context, obj *bean.Bean) ([]*bean.Link, error) {
	// Convert []Link to []*Link
	result := make([]*bean.Link, len(obj.Links))
	for i := range obj.Links {
		result[i] = &obj.Links[i]
	}
	return result, nil
}

// BlockedBy is the resolver for the blockedBy field.
func (r *beanResolver) BlockedBy(ctx context.Context, obj *bean.Bean) ([]*bean.Bean, error) {
	incoming := r.Core.FindIncomingLinks(obj.ID)
	var result []*bean.Bean
	for _, link := range incoming {
		if link.LinkType == "blocks" {
			result = append(result, link.FromBean)
		}
	}
	return result, nil
}

// Blocks is the resolver for the blocks field.
func (r *beanResolver) Blocks(ctx context.Context, obj *bean.Bean) ([]*bean.Bean, error) {
	var result []*bean.Bean
	for _, link := range obj.Links {
		if link.Type == "blocks" {
			// Filter out broken links
			if target, err := r.Core.Get(link.Target); err == nil {
				result = append(result, target)
			}
		}
	}
	return result, nil
}

// Parent is the resolver for the parent field.
func (r *beanResolver) Parent(ctx context.Context, obj *bean.Bean) (*bean.Bean, error) {
	for _, link := range obj.Links {
		if link.Type == "parent" {
			// Filter out broken links
			if target, err := r.Core.Get(link.Target); err == nil {
				return target, nil
			}
		}
	}
	return nil, nil
}

// Children is the resolver for the children field.
func (r *beanResolver) Children(ctx context.Context, obj *bean.Bean) ([]*bean.Bean, error) {
	incoming := r.Core.FindIncomingLinks(obj.ID)
	var result []*bean.Bean
	for _, link := range incoming {
		if link.LinkType == "parent" {
			result = append(result, link.FromBean)
		}
	}
	return result, nil
}

// Duplicates is the resolver for the duplicates field.
// Bidirectional: returns both outgoing and incoming 'duplicates' links.
func (r *beanResolver) Duplicates(ctx context.Context, obj *bean.Bean) ([]*bean.Bean, error) {
	seen := make(map[string]bool)
	var result []*bean.Bean

	// Outgoing links
	for _, link := range obj.Links {
		if link.Type == "duplicates" {
			if target, err := r.Core.Get(link.Target); err == nil && !seen[target.ID] {
				seen[target.ID] = true
				result = append(result, target)
			}
		}
	}

	// Incoming links
	for _, link := range r.Core.FindIncomingLinks(obj.ID) {
		if link.LinkType == "duplicates" && !seen[link.FromBean.ID] {
			seen[link.FromBean.ID] = true
			result = append(result, link.FromBean)
		}
	}

	return result, nil
}

// Related is the resolver for the related field.
// Bidirectional: returns both outgoing and incoming 'related' links.
func (r *beanResolver) Related(ctx context.Context, obj *bean.Bean) ([]*bean.Bean, error) {
	seen := make(map[string]bool)
	var result []*bean.Bean

	// Outgoing links
	for _, link := range obj.Links {
		if link.Type == "related" {
			if target, err := r.Core.Get(link.Target); err == nil && !seen[target.ID] {
				seen[target.ID] = true
				result = append(result, target)
			}
		}
	}

	// Incoming links
	for _, link := range r.Core.FindIncomingLinks(obj.ID) {
		if link.LinkType == "related" && !seen[link.FromBean.ID] {
			seen[link.FromBean.ID] = true
			result = append(result, link.FromBean)
		}
	}

	return result, nil
}

// TargetBean is the resolver for the targetBean field.
func (r *linkResolver) TargetBean(ctx context.Context, obj *bean.Link) (*bean.Bean, error) {
	// Filter out broken links by returning nil
	target, err := r.Core.Get(obj.Target)
	if err == beancore.ErrNotFound {
		return nil, nil
	}
	return target, err
}

// CreateBean is the resolver for the createBean field.
func (r *mutationResolver) CreateBean(ctx context.Context, input model.CreateBeanInput) (*bean.Bean, error) {
	b := &bean.Bean{
		Slug:  bean.Slugify(input.Title),
		Title: input.Title,
		Type:  "task", // default
	}

	// Optional fields with defaults documented in schema
	if input.Type != nil {
		b.Type = *input.Type
	}
	if input.Status != nil {
		b.Status = *input.Status
	}
	if input.Priority != nil {
		b.Priority = *input.Priority
	}
	if input.Body != nil {
		b.Body = *input.Body
	}
	if len(input.Tags) > 0 {
		b.Tags = input.Tags
	}

	// Add links
	for _, link := range input.Links {
		b.Links = append(b.Links, bean.Link{
			Type:   link.Type,
			Target: link.Target,
		})
	}

	if err := r.Core.Create(b); err != nil {
		return nil, err
	}

	return b, nil
}

// UpdateBean is the resolver for the updateBean field.
func (r *mutationResolver) UpdateBean(ctx context.Context, id string, input model.UpdateBeanInput) (*bean.Bean, error) {
	b, err := r.Core.Get(id)
	if err != nil {
		return nil, err
	}

	// Update fields if provided
	if input.Title != nil {
		b.Title = *input.Title
	}
	if input.Status != nil {
		b.Status = *input.Status
	}
	if input.Type != nil {
		b.Type = *input.Type
	}
	if input.Priority != nil {
		b.Priority = *input.Priority
	}
	if input.Body != nil {
		b.Body = *input.Body
	}
	if input.Tags != nil {
		b.Tags = input.Tags
	}

	if err := r.Core.Update(b); err != nil {
		return nil, err
	}

	return b, nil
}

// DeleteBean is the resolver for the deleteBean field.
func (r *mutationResolver) DeleteBean(ctx context.Context, id string) (bool, error) {
	// Verify bean exists
	_, err := r.Core.Get(id)
	if err != nil {
		return false, err
	}

	// Remove incoming links first
	if _, err := r.Core.RemoveLinksTo(id); err != nil {
		return false, err
	}

	// Delete the bean
	if err := r.Core.Delete(id); err != nil {
		return false, err
	}

	return true, nil
}

// AddLink is the resolver for the addLink field.
func (r *mutationResolver) AddLink(ctx context.Context, id string, link model.LinkInput) (*bean.Bean, error) {
	b, err := r.Core.Get(id)
	if err != nil {
		return nil, err
	}

	b.Links = b.Links.Add(link.Type, link.Target)

	if err := r.Core.Update(b); err != nil {
		return nil, err
	}

	return b, nil
}

// RemoveLink is the resolver for the removeLink field.
func (r *mutationResolver) RemoveLink(ctx context.Context, id string, link model.LinkInput) (*bean.Bean, error) {
	b, err := r.Core.Get(id)
	if err != nil {
		return nil, err
	}

	b.Links = b.Links.Remove(link.Type, link.Target)

	if err := r.Core.Update(b); err != nil {
		return nil, err
	}

	return b, nil
}

// Bean is the resolver for the bean field.
func (r *queryResolver) Bean(ctx context.Context, id string) (*bean.Bean, error) {
	b, err := r.Core.Get(id)
	if err == beancore.ErrNotFound {
		return nil, nil
	}
	return b, err
}

// Beans is the resolver for the beans field.
func (r *queryResolver) Beans(ctx context.Context, filter *model.BeanFilter) ([]*bean.Bean, error) {
	var beans []*bean.Bean

	// If search filter is provided, start with search results
	if filter != nil && filter.Search != nil && *filter.Search != "" {
		searchResults, err := r.Core.Search(*filter.Search)
		if err != nil {
			return nil, err
		}
		beans = searchResults
	} else {
		beans = r.Core.All()
	}

	if filter == nil {
		return beans, nil
	}

	// Apply filters
	result := beans

	// Status filters
	if len(filter.Status) > 0 {
		result = filterByField(result, filter.Status, func(b *bean.Bean) string { return b.Status })
	}
	if len(filter.ExcludeStatus) > 0 {
		result = excludeByField(result, filter.ExcludeStatus, func(b *bean.Bean) string { return b.Status })
	}

	// Type filters
	if len(filter.Type) > 0 {
		result = filterByField(result, filter.Type, func(b *bean.Bean) string { return b.Type })
	}
	if len(filter.ExcludeType) > 0 {
		result = excludeByField(result, filter.ExcludeType, func(b *bean.Bean) string { return b.Type })
	}

	// Priority filters (empty priority treated as "normal")
	if len(filter.Priority) > 0 {
		result = filterByPriority(result, filter.Priority)
	}
	if len(filter.ExcludePriority) > 0 {
		result = excludeByPriority(result, filter.ExcludePriority)
	}

	// Tag filters
	if len(filter.Tags) > 0 {
		result = filterByTags(result, filter.Tags)
	}
	if len(filter.ExcludeTags) > 0 {
		result = excludeByTags(result, filter.ExcludeTags)
	}

	// Link filters
	if len(filter.HasLinks) > 0 {
		result = filterByOutgoingLinks(result, filter.HasLinks)
	}
	if len(filter.NoLinks) > 0 {
		result = excludeByOutgoingLinks(result, filter.NoLinks)
	}
	if len(filter.LinkedAs) > 0 {
		result = filterByIncomingLinks(result, filter.LinkedAs, r.Core)
	}
	if len(filter.NoLinkedAs) > 0 {
		result = excludeByIncomingLinks(result, filter.NoLinkedAs, r.Core)
	}

	return result, nil
}

// Bean returns BeanResolver implementation.
func (r *Resolver) Bean() BeanResolver { return &beanResolver{r} }

// Link returns LinkResolver implementation.
func (r *Resolver) Link() LinkResolver { return &linkResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type beanResolver struct{ *Resolver }
type linkResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
